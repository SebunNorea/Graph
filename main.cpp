#include <iostream>
#include <queue>
#include <vector>
using namespace std;

const int MAX_N = 100; // максимальное количество участников
vector<int> g[MAX_N]; // граф связей

void bfs(int s, int d) { // s - начальный участник, d - глубина поиска
    bool visited[MAX_N] = {false}; // массив флагов для отметки посещенных вершин
    int distance[MAX_N] = {0}; // массив для хранения расстояния до начальной вершины
    queue<int> q; // очередь для обхода графа по уровням
    
    visited[s] = true; // помечаем начальную вершину как посещенную
    q.push(s); // добавляем начальную вершину в очередь
    while (!q.empty()) { // пока очередь не пуста
        int u = q.front(); // извлекаем вершину из очереди
        q.pop();
        for (int i = 0; i < g[u].size(); i++) { // обходим всех соседей вершины
            int v = g[u][i];
            if (!visited[v]) { // если соседняя вершина не посещена
                visited[v] = true; // помечаем ее как посещенную
                distance[v] = distance[u] + 1; // увеличиваем расстояние до начальной вершины
                if (distance[v] == d) { // если расстояние соответствует глубине поиска
                    cout << s << " -> " << v << endl; // выводим пару знакомств
                }
                q.push(v); // добавляем соседнюю вершину в очередь
            }
        }
    }
}

int main() {
    int n, m; // n - количество участников, m - количество связей
    cin >> n >> m;
    for (int i = 0; i < m; i++) { // считываем граф связей
        int u, v;
        cin >> u >> v;
        g[u].push_back(v); // добавляем связь u -> v
        g[v].push_back(u); // добавляем связь v -> u (если граф неориентированный)
    }
  
    for (int i = 0; i < n; i++) { // выполняем поиск для всех участников
        bfs(i, 3); // ищем все пары знакомств через три рукопожатия
    }
  
    return 0;
}
